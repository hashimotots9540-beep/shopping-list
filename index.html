import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { 
  getAuth, 
  signInAnonymously, 
  onAuthStateChanged,
  signInWithCustomToken
} from 'firebase/auth';
import { 
  getFirestore, 
  collection, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  doc, 
  query, 
  onSnapshot, 
  orderBy, 
  serverTimestamp 
} from 'firebase/firestore';
import { 
  Plus, 
  Check, 
  Trash2, 
  Archive, 
  RotateCcw, 
  ShoppingCart, 
  History, 
  Settings, 
  Users
} from 'lucide-react';

// --- Firebase Configuration ---
const firebaseConfig = JSON.parse(__firebase_config);
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

export default function App() {
  const [user, setUser] = useState(null);
  const [items, setItems] = useState(() => {
    const saved = localStorage.getItem('shopping_items_cache');
    return saved ? JSON.parse(saved) : [];
  });
  const [newItemName, setNewItemName] = useState('');
  const [loading, setLoading] = useState(true);
  const [groupId, setGroupId] = useState(() => localStorage.getItem('shopping_app_group_id') || 'family'); 
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [tempGroupId, setTempGroupId] = useState(groupId);
  const [activeTab, setActiveTab] = useState('list'); 

  useEffect(() => {
    // --- PWA Branding Clean-up ---
    // これによりホーム画面追加後の「Gemini」という名前を「買い物メモ」に上書きします
    document.title = "買い物メモ";
    
    const metaTags = [
      { name: "apple-mobile-web-app-title", content: "買い物メモ" },
      { name: "apple-mobile-web-app-capable", content: "yes" },
      { name: "apple-mobile-web-app-status-bar-style", content: "black-translucent" },
      { name: "mobile-web-app-capable", content: "yes" }
    ];

    metaTags.forEach(tag => {
      let element = document.querySelector(`meta[name="${tag.name}"]`);
      if (!element) {
        element = document.createElement('meta');
        element.name = tag.name;
        document.head.appendChild(element);
      }
      element.content = tag.content;
    });
  }, []);

  useEffect(() => {
    const initAuth = async () => {
      try {
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
          await signInWithCustomToken(auth, __initial_auth_token);
        } else {
          await signInAnonymously(auth);
        }
      } catch (error) {
        console.error("Auth error:", error);
      }
    };
    initAuth();

    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
    });
    return () => unsubscribe();
  }, []);

  useEffect(() => {
    if (!user) return;
    const collectionName = `shopping-list-${groupId}`;
    const q = query(
      collection(db, 'artifacts', appId, 'public', 'data', collectionName),
      orderBy('createdAt', 'desc')
    );
    const unsubscribe = onSnapshot(q, (snapshot) => {
      const loadedItems = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toMillis?.() || Date.now()
      }));
      setItems(loadedItems);
      localStorage.setItem('shopping_items_cache', JSON.stringify(loadedItems));
      setLoading(false);
    }, (error) => {
      console.error("Firestore error:", error);
      setLoading(false);
    });
    return () => unsubscribe();
  }, [user, groupId]);

  const addItem = async (e) => {
    e.preventDefault();
    if (!newItemName.trim() || !user) return;
    const collectionName = `shopping-list-${groupId}`;
    const name = newItemName.trim();
    setNewItemName('');
    try {
      await addDoc(collection(db, 'artifacts', appId, 'public', 'data', collectionName), {
        name,
        completed: false,
        archived: false,
        createdAt: serverTimestamp(),
        createdBy: user.uid
      });
    } catch (error) { console.error(error); }
  };

  const toggleComplete = async (id, currentStatus) => {
    const collectionName = `shopping-list-${groupId}`;
    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', collectionName, id), { completed: !currentStatus });
  };

  const archiveItem = async (id) => {
    const collectionName = `shopping-list-${groupId}`;
    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', collectionName, id), { archived: true, archivedAt: serverTimestamp() });
  };

  const restoreItem = async (id) => {
    const collectionName = `shopping-list-${groupId}`;
    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', collectionName, id), { archived: false, createdAt: serverTimestamp() });
  };

  const deleteItem = async (id) => {
    const collectionName = `shopping-list-${groupId}`;
    await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', collectionName, id));
  };

  const saveSettings = () => {
    const trimmed = tempGroupId.trim();
    if (trimmed) {
      setGroupId(trimmed);
      localStorage.setItem('shopping_app_group_id', trimmed);
      localStorage.removeItem('shopping_items_cache');
      setItems([]);
      setIsSettingsOpen(false);
    }
  };

  const activeItems = items.filter(item => !item.archived);
  const archivedItems = items.filter(item => item.archived);

  return (
    <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans overflow-hidden select-none touch-manipulation">
      {/* Header with notch spacing */}
      <header className="bg-white shadow-sm z-10 px-4 py-3 flex justify-between items-center shrink-0 border-b border-gray-100 pt-[env(safe-area-inset-top,20px)]">
        <div className="flex items-center gap-2">
          <div className="bg-green-500 text-white p-1.5 rounded-xl shadow-sm">
            <ShoppingCart size={20} />
          </div>
          <h1 className="font-bold text-lg tracking-tight">
            {groupId === 'family' ? 'お買い物メモ' : groupId}
          </h1>
        </div>
        <button onClick={() => setIsSettingsOpen(true)} className="p-2 text-gray-400 active:text-gray-600 transition-colors">
          <Settings size={22} />
        </button>
      </header>

      <main className="flex-1 overflow-y-auto pb-32">
        <div className="px-4 py-4 space-y-3 max-w-2xl mx-auto">
          {activeTab === 'list' ? (
            activeItems.length === 0 && !loading ? (
              <div className="text-center py-20 flex flex-col items-center gap-4 animate-in fade-in duration-500">
                <div className="bg-gray-100 p-6 rounded-full text-gray-300"><ShoppingCart size={48} /></div>
                <p className="text-gray-400 font-medium">リストは空っぽです</p>
              </div>
            ) : (
              activeItems.map(item => (
                <SwipeableItem 
                  key={item.id} 
                  item={item} 
                  onToggle={() => toggleComplete(item.id, item.completed)}
                  onArchive={() => archiveItem(item.id)}
                />
              ))
            )
          ) : (
            archivedItems.length === 0 ? (
              <div className="text-center py-20 text-gray-400"><p>履歴はありません</p></div>
            ) : (
              archivedItems.map(item => (
                <div key={item.id} className="bg-white p-4 rounded-2xl shadow-sm border border-gray-100 flex justify-between items-center opacity-80">
                  <span className="text-gray-500 line-through truncate mr-2">{item.name}</span>
                  <div className="flex gap-2 shrink-0">
                    <button onClick={() => restoreItem(item.id)} className="p-2.5 text-green-600 bg-green-50 rounded-full active:scale-90 transition-transform"><RotateCcw size={18} /></button>
                    <button onClick={() => deleteItem(item.id)} className="p-2.5 text-red-400 bg-red-50 rounded-full active:scale-90 transition-transform"><Trash2 size={18} /></button>
                  </div>
                </div>
              ))
            )
          )}
        </div>
      </main>

      {/* Input Form with modern floating style */}
      {activeTab === 'list' && (
        <div className="fixed bottom-24 left-0 right-0 px-4 pointer-events-none z-30">
          <form onSubmit={addItem} className="flex gap-2 pointer-events-auto max-w-2xl mx-auto bg-white p-1.5 rounded-full shadow-2xl border border-gray-100 ring-4 ring-black/5">
            <input
              type="text"
              value={newItemName}
              onChange={(e) => setNewItemName(e.target.value)}
              placeholder="何を買う？"
              className="flex-1 bg-transparent px-4 py-2 focus:outline-none text-lg select-text"
            />
            <button type="submit" disabled={!newItemName.trim()} className="bg-green-500 text-white rounded-full p-3 shadow-md disabled:opacity-30 active:scale-95 transition-transform">
              <Plus size={24} strokeWidth={3} />
            </button>
          </form>
        </div>
      )}

      <nav className="bg-white/95 backdrop-blur-md border-t border-gray-100 shrink-0 z-20 pb-[env(safe-area-inset-bottom,10px)]">
        <div className="flex justify-around items-center h-20 max-w-2xl mx-auto px-6">
          <button onClick={() => setActiveTab('list')} className={`flex flex-col items-center transition-colors ${activeTab === 'list' ? 'text-green-600' : 'text-gray-400'}`}>
            <ShoppingCart size={26} strokeWidth={activeTab === 'list' ? 2.5 : 2} />
            <span className="text-[10px] mt-1 font-bold">リスト</span>
          </button>
          <button onClick={() => setActiveTab('archive')} className={`flex flex-col items-center transition-colors ${activeTab === 'archive' ? 'text-green-600' : 'text-gray-400'}`}>
            <History size={26} strokeWidth={activeTab === 'archive' ? 2.5 : 2} />
            <span className="text-[10px] mt-1 font-bold">履歴</span>
          </button>
        </div>
      </nav>

      {/* Settings Modal */}
      {isSettingsOpen && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-end sm:items-center justify-center z-50 p-0 sm:p-4">
          <div className="bg-white rounded-t-3xl sm:rounded-3xl w-full max-w-md p-8 shadow-2xl animate-in slide-in-from-bottom-10">
            <h2 className="text-2xl font-black mb-2 flex items-center gap-2"><Users size={28} className="text-green-500" />家族と共有</h2>
            <p className="text-gray-500 mb-6">同じ「合言葉」を使っている人とリストが同期されます。</p>
            <input
              type="text"
              value={tempGroupId}
              onChange={(e) => setTempGroupId(e.target.value)}
              className="w-full bg-gray-50 border-2 border-gray-100 rounded-2xl px-5 py-4 focus:border-green-500 outline-none text-lg font-bold select-text"
              placeholder="例: sato-family"
            />
            <div className="flex gap-3 mt-6">
              <button onClick={() => { setIsSettingsOpen(false); setTempGroupId(groupId); }} className="flex-1 py-4 text-gray-500 bg-gray-100 rounded-2xl font-bold">キャンセル</button>
              <button onClick={saveSettings} className="flex-1 py-4 bg-green-500 text-white rounded-2xl font-bold shadow-lg shadow-green-200">保存</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

function SwipeableItem({ item, onToggle, onArchive }) {
  const [touchStart, setTouchStart] = useState(null);
  const [offset, setOffset] = useState(0);
  const isDragging = useRef(false);

  const onStart = (clientX) => { setTouchStart(clientX); isDragging.current = true; };
  const onMove = (clientX) => {
    if (!isDragging.current) return;
    const currentOffset = clientX - touchStart;
    if (currentOffset < 0) setOffset(Math.max(currentOffset, -120));
  };
  const onEnd = () => {
    if (offset < -80) onArchive();
    setOffset(0);
    isDragging.current = false;
  };

  return (
    <div className="relative overflow-hidden rounded-2xl h-[72px] shrink-0">
      <div className="absolute inset-0 bg-orange-500 flex items-center justify-end px-8 text-white font-bold">
        <div className="flex flex-col items-center"><Archive size={24} /><span className="text-[10px]">完了</span></div>
      </div>
      <div 
        className="absolute inset-0 bg-white p-4 shadow-sm border border-gray-100 flex items-center gap-4 transition-transform duration-200 ease-out"
        style={{ transform: `translateX(${offset}px)` }}
        onTouchStart={(e) => onStart(e.touches[0].clientX)}
        onTouchMove={(e) => onMove(e.touches[0].clientX)}
        onTouchEnd={onEnd}
        onMouseDown={(e) => onStart(e.clientX)}
        onMouseMove={(e) => onMove(e.clientX)}
        onMouseUp={onEnd}
        onMouseLeave={onEnd}
        onClick={() => { if (Math.abs(offset) < 5) onToggle(); }}
      >
        <div className={`shrink-0 w-8 h-8 rounded-full border-2 flex items-center justify-center transition-all ${item.completed ? 'bg-green-500 border-green-500 text-white' : 'border-gray-200 text-transparent'}`}>
          <Check size={18} strokeWidth={4} />
        </div>
        <span className={`text-lg font-medium truncate flex-1 transition-all ${item.completed ? 'text-gray-300 line-through' : 'text-gray-700'}`}>{item.name}</span>
        <div className="flex flex-col gap-1 opacity-20"><div className="w-1 h-1 bg-gray-400 rounded-full" /><div className="w-1 h-1 bg-gray-400 rounded-full" /><div className="w-1 h-1 bg-gray-400 rounded-full" /></div>
      </div>
    </div>
  );
}
