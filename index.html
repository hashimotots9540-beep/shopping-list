<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>買い物メモ</title>
    
    <!-- PWA Settings -->
    <meta name="theme-color" content="#22c55e">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="買い物メモ">
    
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/lucide-icons/lucide/main/icons/shopping-cart.png">
    
    <!-- Web App Manifest -->
    <link rel="manifest" id="pwa-manifest">
    <script>
        // PWAマニフェストの動的生成
        const manifest = {
            "name": "買い物メモ",
            "short_name": "買い物",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#ffffff",
            "theme_color": "#22c55e",
            "orientation": "portrait",
            "icons": [
                {
                    "src": "https://raw.githubusercontent.com/lucide-icons/lucide/main/icons/shopping-cart.png",
                    "sizes": "192x192",
                    "type": "image/png",
                    "purpose": "any maskable"
                },
                {
                    "src": "https://raw.githubusercontent.com/lucide-icons/lucide/main/icons/shopping-cart.png",
                    "sizes": "512x512",
                    "type": "image/png",
                    "purpose": "any maskable"
                }
            ]
        };
        const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        document.querySelector('#pwa-manifest').setAttribute('href', URL.createObjectURL(blob));

        // インストールイベントの捕捉（React起動前に確実にキャッチする）
        window.deferredPrompt = null;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            window.deferredPrompt = e;
            // React側にイベント通知
            window.dispatchEvent(new CustomEvent('pwa-ready'));
        });
    </script>

    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, orderBy, addDoc, updateDoc, deleteDoc, doc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // ==========================================
        // ★ここにあなたのFirebase設定を貼り付けてください★
        // ==========================================
      const firebaseConfig = {
  apiKey: "AIzaSyDIAGr2mjSyqrk22jIqrEsfcSP9CCmr5wM",
  authDomain: "awsome-ee102.firebaseapp.com",
  projectId: "awsome-ee102",
  storageBucket: "awsome-ee102.firebasestorage.app",
  messagingSenderId: "113529271126",
  appId: "1:113529271126:web:c2dc9667a0fba90712dcf7",
  measurementId: "G-TR7LXHTE8Z"
};

        const appId = "shopping-app-v1";

        async function init() {
            try {
                let config = firebaseConfig;
                if (!config.apiKey && typeof __firebase_config !== 'undefined') {
                    config = JSON.parse(__firebase_config);
                }

                if (config && config.apiKey) {
                    const app = initializeApp(config);
                    const auth = getAuth(app);
                    const db = getFirestore(app);
                    
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }

                    window.FB_SERVICES = { auth, db, appId, collection, query, onSnapshot, orderBy, addDoc, updateDoc, deleteDoc, doc, serverTimestamp, signInAnonymously, onAuthStateChanged };
                    window.dispatchEvent(new CustomEvent('firebase-ready'));
                }
            } catch (e) { console.error("Firebase Init Error:", e); }
        }
        init();

        // Service Worker for Android (Required for PWA)
        if ('serviceWorker' in navigator) {
            const swCode = `
                self.addEventListener('install', e => self.skipWaiting());
                self.addEventListener('activate', e => e.waitUntil(clients.claim()));
                self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
            `;
            const blob = new Blob([swCode], { type: 'text/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(blob))
                .then(() => console.log('SW Registered'))
                .catch(e => console.log('SW Error:', e));
        }
    </script>

    <style>
        :root { --sat: env(safe-area-inset-top); --sab: env(safe-area-inset-bottom); }
        * { -webkit-tap-highlight-color: transparent; outline: none; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f9fafb;
            user-select: none; -webkit-user-select: none;
            overscroll-behavior-y: none;
        }
        input { user-select: text; -webkit-user-select: text; }
        .header-pad { padding-top: calc(var(--sat) + 12px); }
        .footer-pad { padding-bottom: calc(var(--sab) + 8px); }
        .swipe-item { position: relative; overflow: hidden; border-radius: 1rem; background: #fb923c; }
        .swipe-content { 
            position: relative; z-index: 10; background: white; 
            display: flex; align-items: center; padding: 1rem; width: 100%; 
        }
        .fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, Component } = React;

        // --- Error Boundary ---
        class ErrorBoundary extends Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error, errorInfo) { console.error("App Error:", error, errorInfo); }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="flex h-screen items-center justify-center flex-col p-6 text-center">
                            <h2 className="text-xl font-bold text-gray-800 mb-2">エラーが発生しました</h2>
                            <button onClick={() => window.location.reload()} className="bg-green-500 text-white px-6 py-3 rounded-xl font-bold">再読み込み</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        const Icon = ({ name, size = 24, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (window.lucide && ref.current) {
                    ref.current.innerHTML = `<i data-lucide="${name}"></i>`;
                    window.lucide.createIcons({
                        root: ref.current,
                        icons: { [name]: window.lucide.icons[name] },
                        attrs: { class: className, width: size, height: size }
                    });
                }
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center', justifyContent: 'center' }} />;
        };

        const ShoppingItem = ({ item, onToggle, onArchive, onRestore, onDelete, isActive }) => {
            const [startX, setStartX] = useState(0);
            const [currentX, setCurrentX] = useState(0);
            const [isDragging, setIsDragging] = useState(false);
            const [isArchiving, setIsArchiving] = useState(false);

            const handleTouchStart = (e) => {
                if (!isActive || isArchiving) return;
                setStartX(e.touches[0].clientX);
                setIsDragging(true);
            };

            const handleTouchMove = (e) => {
                if (!isDragging || isArchiving) return;
                const diff = e.touches[0].clientX - startX;
                if (diff < 0) setCurrentX(Math.max(diff, -150));
            };

            const handleTouchEnd = () => {
                if (!isDragging) return;
                setIsDragging(false);
                if (currentX < -70) {
                    setIsArchiving(true);
                    setCurrentX(-1000);
                    setTimeout(() => onArchive(item), 500);
                } else {
                    setCurrentX(0);
                }
            };

            const handleClick = (e) => {
                if (Math.abs(currentX) < 5 && isActive && !isArchiving) {
                    onToggle(item);
                }
            };

            return (
                <div className="swipe-item mb-3 shadow-sm border border-gray-100 fade-in">
                    <div className="absolute inset-y-0 right-0 flex items-center pr-6 text-white gap-1">
                        <Icon name="archive" size={24} />
                        <span className="text-xs font-bold">完了</span>
                    </div>
                    <div 
                        className="swipe-content"
                        style={{ 
                            transform: `translateX(${currentX}px)`,
                            transition: isDragging ? 'none' : 'transform 0.5s cubic-bezier(0.2, 0, 0, 1)'
                        }}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                        onClick={handleClick}
                    >
                        {isActive ? (
                            <>
                                <button 
                                    className={`w-10 h-10 rounded-full border-2 flex items-center justify-center shrink-0 transition-colors ${item.completed ? 'bg-green-500 border-green-500 text-white' : 'border-gray-200'}`}
                                >
                                    {item.completed && <Icon name="check" size={24} />}
                                </button>
                                <span className={`text-xl ml-4 flex-1 truncate font-medium ${item.completed ? 'text-gray-300 line-through' : 'text-gray-700'}`}>
                                    {item.name}
                                </span>
                                {item.completed && !isDragging && <div className="text-gray-300"><Icon name="chevron-left" size={20} /></div>}
                            </>
                        ) : (
                            <>
                                <span className="text-gray-400 line-through flex-1 truncate text-lg">{item.name}</span>
                                <div className="flex gap-3 shrink-0">
                                    <button onClick={(e) => { e.stopPropagation(); onRestore(item); }} className="p-3 text-green-600 bg-green-50 rounded-full active:scale-90"><Icon name="rotate-ccw" size={24} /></button>
                                    <button onClick={(e) => { e.stopPropagation(); onDelete(item.id); }} className="p-3 text-red-400 bg-red-50 rounded-full active:scale-90"><Icon name="trash-2" size={24} /></button>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const App = () => {
            const [fb, setFb] = useState(window.FB_SERVICES || null);
            const [user, setUser] = useState(null);
            const [items, setItems] = useState([]);
            const [newItemName, setNewItemName] = useState('');
            const [groupId, setGroupId] = useState(() => localStorage.getItem('shopping_app_group_id') || 'family');
            const [activeTab, setActiveTab] = useState('list');
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [installable, setInstallable] = useState(false);

            useEffect(() => {
                const handleReady = () => setFb(window.FB_SERVICES);
                window.addEventListener('firebase-ready', handleReady);
                if (window.FB_SERVICES) setFb(window.FB_SERVICES);

                // PWAインストールイベントの監視
                const handlePWA = () => setInstallable(true);
                window.addEventListener('pwa-ready', handlePWA);
                if (window.deferredPrompt) setInstallable(true);

                return () => {
                    window.removeEventListener('firebase-ready', handleReady);
                    window.removeEventListener('pwa-ready', handlePWA);
                };
            }, []);

            // インストール実行関数
            const installApp = () => {
                const promptEvent = window.deferredPrompt;
                if (!promptEvent) return;
                promptEvent.prompt();
                promptEvent.userChoice.then((choice) => {
                    if (choice.outcome === 'accepted') {
                        setInstallable(false);
                        window.deferredPrompt = null;
                    }
                });
            };

            useEffect(() => {
                if (!fb) return;
                const unsub = fb.onAuthStateChanged(fb.auth, u => setUser(u));
                return unsub;
            }, [fb]);

            useEffect(() => {
                if (!fb || !user) return;
                const q = fb.query(
                    fb.collection(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`),
                    // ★修正：並び順を昇順（古いものが上、新しいものが下）に変更
                    fb.orderBy('createdAt', 'asc')
                );
                return fb.onSnapshot(q, (ss) => {
                    setItems(ss.docs.map(d => ({ id: d.id, ...d.data() })));
                }, console.error);
            }, [fb, user, groupId]);

            const addItem = async (e) => {
                e.preventDefault();
                if (!newItemName.trim() || !fb || !user) return;
                const name = newItemName.trim();
                setNewItemName('');
                try {
                    await fb.addDoc(fb.collection(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`), {
                        name, completed: false, archived: false, createdAt: fb.serverTimestamp()
                    });
                    // 自動スクロール
                    setTimeout(() => {
                        const main = document.querySelector('main');
                        if(main) main.scrollTop = main.scrollHeight;
                    }, 100);
                } catch(err) { alert("追加エラー: " + err.message); }
            };

            const toggle = async (item) => {
                if (!fb) return;
                try {
                    await fb.updateDoc(fb.doc(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`, item.id), { completed: !item.completed });
                } catch (e) { console.error(e); }
            };

            const archive = async (item) => {
                if (!fb) return;
                await fb.updateDoc(fb.doc(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`, item.id), { archived: true });
            };

            const restore = async (item) => {
                if (!fb) return;
                await fb.updateDoc(fb.doc(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`, item.id), { archived: false, completed: false });
            };

            const deleteItem = async (id) => {
                if (!fb || !confirm("完全に削除しますか？")) return;
                await fb.deleteDoc(fb.doc(fb.db, 'artifacts', fb.appId, 'public', 'data', `shopping-list-${groupId}`, id));
            };

            if (!fb) return <div className="flex h-screen items-center justify-center text-gray-400 font-bold animate-pulse">CONNECTING...</div>;

            return (
                <div className="flex flex-col max-w-md mx-auto bg-gray-50 overflow-hidden shadow-2xl" style={{ height: '100dvh' }}>
                    <header className="bg-white px-6 header-pad border-b flex justify-between items-center shrink-0 z-20">
                        <div className="flex items-center gap-3 py-2">
                            <div className="bg-green-500 text-white p-2 rounded-xl"><Icon name="shopping-cart" size={24} /></div>
                            <h1 className="font-bold text-2xl text-gray-800">{groupId}</h1>
                        </div>
                        <button onClick={() => setIsSettingsOpen(true)} className="p-3 text-gray-400 active:bg-gray-100 rounded-full relative">
                            <Icon name="settings" size={28} />
                            {installable && <span className="absolute top-2 right-2 w-3 h-3 bg-red-500 rounded-full border-2 border-white animate-pulse"></span>}
                        </button>
                    </header>

                    <main className="flex-1 overflow-y-auto px-4 py-4 scroll-smooth">
                        {items.filter(i => (activeTab === 'list' ? !i.archived : i.archived)).length === 0 ? (
                            <div className="text-center py-20 text-gray-300 font-medium text-lg">{activeTab === 'list' ? 'リストは空です' : '履歴はありません'}</div>
                        ) : (
                            items.filter(i => (activeTab === 'list' ? !i.archived : i.archived)).map(item => (
                                <ShoppingItem key={item.id} item={item} onToggle={toggle} onArchive={archive} onRestore={restore} onDelete={deleteItem} isActive={activeTab === 'list'} />
                            ))
                        )}
                    </main>

                    {activeTab === 'list' && (
                        <div className="p-4 bg-white border-t z-20 shadow-[0_-4px_10px_rgba(0,0,0,0.05)]">
                            <form onSubmit={addItem} className="flex gap-3 bg-gray-100 p-2 rounded-2xl">
                                <input value={newItemName} onChange={e => setNewItemName(e.target.value)} placeholder="追加..." className="flex-1 bg-transparent px-4 py-2 outline-none font-bold text-xl text-gray-700" />
                                <button type="submit" disabled={!newItemName.trim()} className="bg-green-500 text-white w-14 h-14 flex items-center justify-center rounded-xl font-bold shadow-lg active:scale-95 disabled:opacity-30"><Icon name="plus" size={32} /></button>
                            </form>
                        </div>
                    )}

                    <nav className="bg-white border-t flex justify-around items-center h-24 footer-pad shrink-0 z-20">
                        <button onClick={() => setActiveTab('list')} className={`flex flex-col items-center gap-1 flex-1 py-2 ${activeTab === 'list' ? 'text-green-600' : 'text-gray-400'}`}>
                            <Icon name="list" size={32} />
                            <span className="text-xs font-bold">リスト</span>
                        </button>
                        <button onClick={() => setActiveTab('archive')} className={`flex flex-col items-center gap-1 flex-1 py-2 ${activeTab === 'archive' ? 'text-green-600' : 'text-gray-400'}`}>
                            <Icon name="history" size={32} />
                            <span className="text-xs font-bold">履歴</span>
                        </button>
                    </nav>

                    {isSettingsOpen && (
                        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-end justify-center">
                            <div className="bg-white w-full rounded-t-3xl p-8 shadow-2xl animate-in slide-in-from-bottom-full footer-pad">
                                <h2 className="text-xl font-bold mb-4">設定</h2>
                                
                                {/* インストールボタン（インストール可能な場合のみ表示） */}
                                {installable && (
                                    <div className="mb-6 p-4 bg-green-50 border-2 border-green-100 rounded-2xl flex items-center justify-between">
                                        <div className="flex items-center gap-3 text-green-700 font-bold">
                                            <Icon name="download" />
                                            <span>アプリとしてインストール</span>
                                        </div>
                                        <button onClick={installApp} className="bg-green-600 text-white px-4 py-2 rounded-xl font-bold text-sm shadow-lg">実行</button>
                                    </div>
                                )}

                                <div className="mb-6">
                                    <label className="text-xs text-gray-400 font-bold uppercase mb-2 block">共有ID (合言葉)</label>
                                    <input defaultValue={groupId} onBlur={e => { setGroupId(e.target.value || 'family'); localStorage.setItem('shopping_app_group_id', e.target.value || 'family'); }} className="w-full bg-gray-50 border-2 rounded-2xl p-4 font-bold text-lg" />
                                </div>

                                <button onClick={() => setIsSettingsOpen(false)} className="w-full bg-gray-200 text-gray-600 py-4 rounded-2xl font-bold text-lg">閉じる</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
    </script>
</body>
</html>

